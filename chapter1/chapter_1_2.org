#+TITLE: Procedures and the Processes They Generate

[[http://sarabander.github.io/sicp/html/index.xhtml][INDEX]]
[[http://sarabander.github.io/sicp/html/1_002e2.xhtml#g_t1_002e2][Bookmark]]


** Snippets
#+begin_src racket :lang sicp :results output
#+end_src

#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
#+end_src

** Recovery
- prmitive arithmetic operations
- compound procedures

** Test 

#+begin_src racket :lang sicp :results output
  (plural 1 3)
#+end_src

#+RESULTS:
: /var/folders/_3/nwly65x92d13qp765t5gqbl40000gn/T/babel-uQgFyv/org-babel-4efJrP.rkt:4:1: plural: unbound identifier
:   in: plural
:   location...:
:    /var/folders/_3/nwly65x92d13qp765t5gqbl40000gn/T/babel-uQgFyv/org-babel-4efJrP.rkt:4:1


** Exercise 1.9
Each of the following two procedures defines
a method for adding two positive integers in terms of the procedures
inc, which increments its argument by 1, and
dec, which decrements its argument by 1.

#+NAME: Exercise1.9
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (+ a b)
    (if (= a 0) 
        b 
        (inc (+ (dec a) b))))

#+end_src

Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5).
Are these processes iterative or recursive?

-first (recursive)
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (+ a b)
    (if (= a 0) 
        b 
        (inc (+ (dec a) b))))

  (+ 4 5)
  (inc (+ 3 5))
  (inc (inc (+ 2 5)))
  (inc (inc (inc (+ 1 5))))
  (inc (inc (inc (inc (+ 0 5)))))
  (inc (inc (inc (inc 5))))
  (inc (inc (inc 6)))
  (inc (inc 7))
  (inc 8)
  9
#+end_src

#+RESULTS:
#+begin_example
9
9
9
9
9
9
9
9
9
9
#+end_example

#+begin_example
9
9
9
9
9
9
9
9
9
9
#+end_example

-second (iterative)
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (+ a b)
    (if (= a 0) 
        b 
        (+ (dec a) (inc b))))

  (+ 4 5)
  (+ 3 6)
  (+ 2 7)
  (+ 1 8)
  (+ 0 9)
#+end_src

#+RESULTS:
: 9
: 9
: 9
: 9
: 9

** Exercise 1.10
The following procedure computes a mathematical function called
Ackermann's function
#+NAME: Exercise1.10
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (A x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                   (A x (- y 1))))))
(A 2 3)
#+end_src

#+RESULTS: Exercise1.10
: 16

What are the values of the following expressions?
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (A 1 10) ;; 2^10
  (A 2 4) ;; 2^16
  (A 3 3) ;; 2^16
#+end_src

#+RESULTS:
: /var/folders/_3/nwly65x92d13qp765t5gqbl40000gn/T/babel-97Wkm1/org-babel-bnmV9f.rkt:4:1: A: unbound identifier
:   in: A
:   location...:
:    /var/folders/_3/nwly65x92d13qp765t5gqbl40000gn/T/babel-97Wkm1/org-babel-bnmV9f.rkt:4:1

Consider the following procedures,
where A is the procedure defined above
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (f n) (A 0 n)) ;; 2 * n
  (define (g n) (A 1 n)) ;; 2^n
  (define (h n) (A 2 n)) ;;
  (define (k n) (* 5 n n))
#+end_src

Give concise mathematical definitions for the functions
computed by the procedures f, g, and h for positive integer
values of n. For example, (k n) computes 5n^2.



** 1.2.2 Tree Recursion

#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (fibonacci n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+
                 (fibonacci (- n 1))
                 (fibonacci (- n 2))))))

  (fibonacci 9)

  (define golden (/ (+ 1 (sqrt 5)) 2))
  (* golden golden)
  (+ golden 1)
  (define (pow x n)
    (if (= n 1) x (* x (pow x (dec n)))))
  (pow 2 10)

  (/ (pow golden 9) (sqrt 5))
#+end_src

#+RESULTS:
: 34
: 2.618033988749895
: 2.618033988749895
: 1024
: 33.994116628998405

*** Example: Counting change
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define dollar 100)
  (define half (/ dollar 2))
  (define quater (/ dollar 4))
  (define dime (/ dollar 10))
  (define nickel (/ dollar 20))
  (define pennie (/ dollar 100))

  (define (count-change amount)
    (ways-to-change amount 5))

  (define (ways-to-change amount kinds-of-coins)
    (cond ((= amount 0) 1)
          ((or (< amount 0)
               (= kinds-of-coins 0))
           0)
          (else
           (+ (ways-to-change amount (- kinds-of-coins 1))
              (ways-to-change (- amount (first-denomination
                                         kinds-of-coins))
                              kinds-of-coins)))))

  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) pennie)
          ((= kinds-of-coins 3) nickel)
          ((= kinds-of-coins 4) dime)
          ((= kinds-of-coins 2) quater)
          ((= kinds-of-coins 5) half)))

  (count-change 10)

#+end_src

#+RESULTS:
: 4





** Exercise 1.11
A function /f/ is defined by the rule

that /f(n) = n if /n/ < 3

and /f(n) = f(n−1) + 2f(n−2) + 3f(n−3)/ if /n ≥ 3./

Write a procedure that computes f
by means of a recursive process.
Write a procedure that computes f
by means of an iterative process.

/Recursive/ process
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (f n)
    (if (< n 3) n
        (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3))))))

  (f 18)
#+end_src

#+RESULTS:
: 1910507

/Iterative/ process
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (f n)
    (if (< n 3) n
        (f-iter n 3 2 1 0)))

  (define (f-iter n count n-1 n-2 n-3)
    (if (= n count) (+ n-1 (* 2 n-2) (* 3 n-3))
        (f-iter n (inc count) (+ n-1 (* 2 n-2) (* 3 n-3)) n-1 n-2)))

  (f 4)
#+end_src

#+RESULTS:
: 11


** Exercise 1.12
The following pattern of numbers is called /Pascal's triangle/

         1
       1   1
     1   2   1
   1   3   3   1
 1   4   6   4   1
       . . .

The number at the edge of triangle are all 1, 
and each number inside the triangle is the sum of the two numbers
above it.
Write a procedure that computes elements of Pascal's triangle
by means of a recursive process.

#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (pascal row column)
    (cond ((or (= row 1) (= row 2)) 1)
          ((or (= column 1) (= column row)) 1)
          (else (+ (pascal (dec row) (dec column)) (pascal (dec row) column)))))

  (pascal 5 2)
#+end_src

#+RESULTS:
: 4

** Exercise 1.13
Prove that /Fib(n)/ is the closest integer to /φ^n/√5/
where /φ=(1+√5)/2/
Hint: Let /ψ=(1−√5)/2/
Use induction and the definition of the Fibonacci numbers
(see 1.2.2) to prove that /Fib(n)=(φ^n−ψ^n)/√5/
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
#+end_src


** Exercise 1.14
Draw the tree illustrating
the process generated by
the count-change procedure of 1.2.2 in making change for 11 cents.
What are the orders of growth of the space and number of steps
used by this process as the amount to be changed increases?

** Exercise 1.15
The sine of an angle (specified in radians)
can be computed by making use of the approximation
/sin x ≈ x/
if x is sufficiently small, and the trigonometric identity

[image]

to reduce the size of the argument of sin.
(For purposes of this exercise an angle is considered “sufficiently small”
if its magnitude is not greater than 0.1 radians.)
These ideas are incorporated in the following procedures:

#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (cube x) (* x x x))

  (define (p x) (- (* 3 x) (* 4 (cube x))))
  (define (sine angle)
    (if (not (> (abs angle) 0.1))
        angle
        (p (sine (/ angle 3.0)))))

#+end_src

#+RESULTS:

1. How many times is the procedure p applied when (sine 12.15) is evaluated?
What is the order of growth in space and number of steps (as a function of a)
used by the process generated by the sine procedure when (sine a) is evaluated?







** Re : Counting change

#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define dollar 100)
  (define pennie (/ dollar 100))
  (define nickel (/ dollar 20))
  (define dime (/ dollar 10))
  (define quater (/ dollar 4))
  (define half (/ dollar 2))

  (define (coin kind)
    (cond ((= kind 1) pennie)
          ((= kind 2) nickel)
          ((= kind 3) dime)
          ((= kind 4) quater)
          ((= kind 5) half)))

  (define (change amount)
    (change-with-specific-coin amount 2))

  (define (change-with-specific-coin amount coin-num)
    ;; (write 1)
    (cond ((or (< amount 0) (= coin-num 0)) 0)
          ((= amount 0) 1)
          (else (+ (change-with-specific-coin amount (dec coin-num)) (change-with-specific-coin (- amount (coin coin-num)) coin-num)))  ))

  (change 50)
#+end_src

#+RESULTS:
: 11

** Expotential Example
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (pow-2 n)
    (if (= n 0) 1
        (+ (pow-2 (dec n)) (pow-2 (dec n)))))
  (pow-2 10)

  (define (pow-3 n)
    (if (= n 0) 1
        (+ (pow-3 (dec n)) (pow-3 (dec n)) (pow-3 (dec n)))))
  (pow-3 5)
#+end_src

#+RESULTS:
: 1024
: 243



** 1.2.4 Exponentiation

/Linear Recursive/
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (expt x n)
    (if (= n 0)
        1
        (* x (expt x (dec n)))))

  (expt 3918 100000)
#+end_src

/Linear Iterative/
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (expt b n)
    (expt-iter b n 1))

  (define (expt-iter b counter product)
    (if (= counter 0)
        product
        (expt-iter b (dec counter) (* b product))))

  (expt 3918 100000)
#+end_src

/Fast Iterative/

#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (square x) (* x x))


  (define (even? n)
    (= (remainder n 2) 0))

  (define (odd? n)
    (not (even? n)))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2)) ) )
          ((odd? n) (* b (fast-expt b (dec n))) ) ))
#+end_src

#+RESULTS:
: 100000


** Exercise 1.16
Design a procedure that evolves an iterative exponentiation process
that uses successive squaring and uses a logarithmic number of steps,
as does fast-expt

#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (square x) (* x x))

  (define (even? n)
    (= (remainder n 2) 0))

  (define (odd? n)
    (not (even? n)))

  (define (expt-iter b n a)
    (cond ((= n 0) a)
          ((even? n) (expt-iter (square b) (/ n 2) a))
          ((odd? n) (expt-iter b (- n 1) (* b a)))))

  (define (expt b n)
    (expt-iter b n 1))


  (expt 2 1)
#+end_src

#+RESULTS:
: 2

** Exercise 1.17
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (even? n)
    (= (remainder n 2) 0))
  (define (odd? n)
    (not (even? n)))

  (define (double x) (+ x x))
  (define (halve x) (/ x 2))

  (define (* a b)
    (cond ((= b 0) 0)
          ((even? b) (* (double a) (halve b)))
          ((odd? b) (+ (* a (dec b)) a))))
  (* 999 1000)
#+end_src

#+RESULTS:
: 999000

** Exercise 1.18
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (even? n)
    (= (remainder n 2) 0))
  (define (odd? n)
    (not (even? n)))

  (define (double x) (+ x x))
  (define (halve x) (/ x 2))

  (define (*-iter x y a)
    (cond ((= y 0) a)
          ((even? y) (*-iter (double x) (halve y) a))
          ((odd? y) (*-iter x (dec y) (+ a x))) ))

  (define (* x y) (*-iter x y 0))

  (* 9 9)
#+end_src

#+RESULTS:
: 81

** Exercise 1.18
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (square x) (* x x))

  (define (even? n)
    (= (remainder n 2) 0))

  (define (fib n)
    (fib-iter 1 0 0 1 n))
  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
          ((even? count)
           (fib-iter a
                     b
                     (+ (square p) (square q))
                     (+ (square q) (* 2 p q))
                     (/ count 2)))
          (else (fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1)))))

  (fib 10)
#+end_src

#+RESULTS:
: 55


** Greatest Common Divisors
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  GCD
#+end_src

#+RESULTS:
: /var/folders/_3/nwly65x92d13qp765t5gqbl40000gn/T/babel-mqYeVI/org-babel-q9YjbS.rkt:4:0: GCD: unbound identifier
:   in: GCD
:   location...:
:    /var/folders/_3/nwly65x92d13qp765t5gqbl40000gn/T/babel-mqYeVI/org-babel-q9YjbS.rkt:4:0


** Fermat's Little Theorem
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (square x) (* x x))
  (define (even? n)
    (= (remainder n 2) 0))
  (define (odd? n)
    (not (even? n)))

  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m))
          ((odd? exp) (remainder (* base (expmod base (dec exp) m)) m))))

  (expmod 5 2 7)
#+end_src

#+RESULTS:
: 4


** Exercise 1.21
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (square x) (* x x))

  (define (smallest-divisor n) (find-divisor n 2))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1 )))))
  (define (divides? a b) (= (remainder b a) 0))

  (smallest-divisor 199)
  (smallest-divisor 1999)
  (smallest-divisor 19999)
#+end_src

#+RESULTS:
: 199
: 1999
: 7

** Exercise 1.22
#+NAME:Exercise1.22_functions
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (square x) (* x x))
  (define (smallest-divisor n) (find-divisor n 2))
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1 )))))
  (define (divides? a b) (= (remainder b a) 0))
  (define (prime? n)
    (= n (smallest-divisor n)))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

  ;; (define (start-prime-test n start-time)
  ;;   (if (prime? n)
  ;;       (report-prime (- (runtime) start-time))))

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time)) #f))

  (define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time) #t)

#+end_src

#+RESULTS: Exercise1.22_functions

#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  <<Exercise1.22_functions>>
  (define (even? n)
    (= (remainder n 2) 0))

  (define (search-for-primes n count)
    (if (even? n) (search-for-primes-helper (inc n) count)
        (search-for-primes-helper n count)))

  (define (search-for-primes-helper n count)
    (cond ((= count 0) (newline))
          ((timed-prime-test n) (search-for-primes-helper (+ n 2) (dec count)))
          (else (search-for-primes-helper (+ n 2) count )))
    )

  (search-for-primes 10000000 3)
#+end_src

#+RESULTS:
#+begin_example

10000001
10000003
10000005
10000007
10000009
10000011
10000013
10000015
10000017
10000019 *** 10
10000021
10000023
10000025
10000027
10000029
10000031
10000033
10000035
10000037
10000039
10000041
10000043
10000045
10000047
10000049
10000051
10000053
10000055
10000057
10000059
10000061
10000063
10000065
10000067
10000069
10000071
10000073
10000075
10000077
10000079 *** 9
10000081
10000083
10000085
10000087
10000089
10000091
10000093
10000095
10000097
10000099
10000101
10000103 *** 9
#+end_example


** Exercise 1.23
#+NAME:Exercise1.23_functions
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (square x) (* x x))
  (define (next x)
    (if (= x 2) 3 (+ x 2)))

  (define (smallest-divisor n) (find-divisor n 2))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (next test-divisor)))))

  (define (divides? a b) (= (remainder b a) 0))
  (define (prime? n)
    (= n (smallest-divisor n)))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time)) #f))

  (define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time) #t)

#+end_src

#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  <<Exercise1.23_functions>>
  (define (even? n)
    (= (remainder n 2) 0))

  (define (search-for-primes n count)
    (if (even? n) (search-for-primes-helper (inc n) count)
        (search-for-primes-helper n count)))

  (define (search-for-primes-helper n count)
    (cond ((= count 0) (newline))
          ((timed-prime-test n) (search-for-primes-helper (+ n 2) (dec count)))
          (else (search-for-primes-helper (+ n 2) count )))
    )

  (search-for-primes 10000000 3)
#+end_src

#+RESULTS:
#+begin_example

10000001
10000003
10000005
10000007
10000009
10000011
10000013
10000015
10000017
10000019 *** 6
10000021
10000023
10000025
10000027
10000029
10000031
10000033
10000035
10000037
10000039
10000041
10000043
10000045
10000047
10000049
10000051
10000053
10000055
10000057
10000059
10000061
10000063
10000065
10000067
10000069
10000071
10000073
10000075
10000077
10000079 *** 6
10000081
10000083
10000085
10000087
10000089
10000091
10000093
10000095
10000097
10000099
10000101
10000103 *** 5
#+end_example

** Exercise 1.24
#+NAME:fast-prime
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes

  (define (square x) (* x x))
  (define (even? n)
    (= (remainder n 2) 0))
  (define (odd? n)
    (not (even? n)))

  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m))
          ((odd? exp) (remainder (* base (expmod base (dec exp) m)) m))))


  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))

  (define (fast-prime? n times)
    (cond ((= times 0) true)
          ((fermat-test n) (fast-prime? n (- times 1)))
          (else false)))
#+end_src

#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  <<fast-prime>>
  (define (smallest-divisor n) (find-divisor n 2))
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1 )))))
  (define (divides? a b) (= (remainder b a) 0))
  (define (prime? n)
    (= n (smallest-divisor n)))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

  (define (timed-fast-prime-test n)
    (newline)
    (display n)
    (start-fast-prime-test n (runtime)))

  (define (start-fast-prime-test n start-time)
    (if (fast-prime? n 1)
        (report-prime (- (runtime) start-time))))

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time))))

  (define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

  (timed-prime-test 1000003)
  (timed-fast-prime-test 1000003)
#+end_src
#+RESULTS:
: 
: 1000003 *** 24
: 1000003 *** 2

** Exercise 1.25
#+NAME:fast-expt
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (square x) (* x x))


  (define (even? n)
    (= (remainder n 2) 0))

  (define (odd? n)
    (not (even? n)))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2)) ) )
          ((odd? n) (* b (fast-expt b (dec n))) ) ))
#+end_src

#+NAME:fast-expmod
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  <<fast-expt>>
  (define (expmod base exp m)
    (remainder (fast-expt base exp) m))

  ;; (expmod 5 2 7)
#+end_src

#+RESULTS:
: 4

#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  <<fast-expmod>>
  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))

  (define (fast-prime? n times)
    (cond ((= times 0) true)
          ((fermat-test n) (fast-prime? n (- times 1)))
          (else false)))

  (fast-prime? 1000033 1)
#+end_src

#+RESULTS:
: #t

#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  <<fast-prime>>
  (fast-prime? 1000033 1)
#+end_src

#+RESULTS:
: #t


** Exercise 1.26
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (square x) (* x x))
  (define (even? n)
    (= (remainder n 2) 0))
  (define (odd? n)
    (not (even? n)))

  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m))
          ((odd? exp) (remainder (* base (expmod base (dec exp) m)) m))))

  (expmod 2 5 3)


  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))



  (define (test n)
    (test-helper n 1))

  (define (test-helper n count)
    (define (try-it a)
      (= (expmod a n n) a))
    (if (try-it count) (display count) (newline))
    (if (> n count) (test-helper n (inc count))))
#+end_src

#+RESULTS:
: 2

** Exercise 1.28
#+begin_src racket :lang sicp :results output :noweb yes :noweb-ref yes
  (define (square x) (* x x))
  (define (even? n)
    (= (remainder n 2) 0))
  (define (odd? n)
    (not (even? n)))

  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m))
          ((odd? exp) (remainder (* base (expmod base (dec exp) m)) m))))

  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))

  (define (fermat-fast-prime? n times)
    (cond ((= times 0) true)
          ((fermat-test n) (fermat-fast-prime? n (- times 1)))
          (else false)))


  ;; (define (miller-expmod base exp m)
  ;;   (cond ((= exp 0) 1)
  ;;         ((even? exp) (remainder (square (miller-expmod base (/ exp 2) m)) m))
  ;;         ((odd? exp) (remainder (* base (miller-expmod base (dec exp) m)) m))))

  (define (miller-expmod base exp m)
    (cond ((= exp 0) 1)

          ((odd? exp) (remainder (* base (miller-expmod base (dec exp) m)) m))

          ((even? exp)
           (if (= (remainder (square (miller-expmod base (/ exp 2) m)) m) 1)
               0
               (remainder (square (miller-expmod base (/ exp 2) m)) m) ))
          ))

  (define (miller-test n)
    (define (try-it a)
      (= (miller-expmod a (- n 1) n) 1))
    (try-it (+ 1 (random (- n 1)))))

  (define (miller-fast-prime? n times)
    (cond ((= times 0) true)
          ((miller-test n) (miller-fast-prime? n (- times 1)))
          (else false)))


  (fermat-test 1105)

  (miller-fast-prime? 2821 1)
#+end_src

#+RESULTS:
: /var/folders/_3/nwly65x92d13qp765t5gqbl40000gn/T/babel-7RTaSN/org-babel-S3p7xz.rkt:37:9: define: not allowed in an expression context
:   in: (define a 3)
:   location...:
:    /var/folders/_3/nwly65x92d13qp765t5gqbl40000gn/T/babel-7RTaSN/org-babel-S3p7xz.rkt:37:9
:   context...:
:    /Applications/Racket v8.7/collects/racket/private/norm-define.rkt:9:4: normalize-definition/mk-rhs
:    /Applications/Racket v8.7/collects/racket/private/norm-define.rkt:165:4: normalize-definition
:    /Applications/Racket v8.7/collects/racket/private/kw.rkt:1161:2
